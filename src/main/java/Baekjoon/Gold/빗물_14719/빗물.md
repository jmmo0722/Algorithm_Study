# 빗물 - 14719

![Solved.ac Tier](https://img.shields.io/badge/solved.ac-Gold%20V-F29D16?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/14719)


`#다이나믹 프로그래밍` `#O(N)` `정답 코드 참고`

---

### 문제
2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.


![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/1.png)
![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14719/2.png)

비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?

### 입력
첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)

두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.

따라서 블록 내부의 빈 공간이 생길 수 없다. 또 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.

### 출력
2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.

빗물이 전혀 고이지 않을 경우 0을 출력하여라.

<hr>

### 핵심 풀이 전략

`메모리: 14232 KB`
`시간: 108 ms`

이 문제의 핵심 원리는 '역방향' 이다.
s 에서 t로 가는 것이 아닌, 반대로 t 에서 s 로 가야 시간 단축과 메모리 낭비를 방지 할 수 있다.

길이가 짧은 문자열에서 긴 문자열로 가게 되면 분기가 무수히 많아지지만, 
반대로 길이가 긴 문자열에서 짧은 문자열로 하나씩 지우면서 오면 분기가 상대적으로 적어진다.

Set<String>을 통해 방문 체크를 하며 que를 방문 한다.

후에 t가 s가 될 수 있다면 true, 그 이전에 큐가 비어지면 false로 출력한다.

---

### 삽질 기록 🧠

- **Set 대신 Map 사용**
    - Map<String, Integer>를 통해 최단 시간까지 저장했지만, 해당 문제는 단순 true/false만 결과로 출력하므로 필요 없다.
    - 그러므로 Set 만으로도 visited 검사가 충분하다.
- **정방향으로 계산**
  - 정방향으로 구현하니 시간 초과가 발생하였다.
  - 이는 역방향으로 구현할 시 해결할 수 있다.

---

### 배운 점 & 보완할 점
- 해당 문제는 '**가중치가 모두 동일한 BFS**' 이다. 이에 시간 보장이 되므로 큐에 중복 삽입을 방지 하기 위해 visited 방문 로직은 필수다.
- 모든 BFS 는 시간 보장이 되어야한다. 즉 항상 짧은 시간이 먼저 큐에서 나와야 한다. 하지만 해당 문제는 가중치가 모두 동일하므로, 단순 visited 검사만 필요하다.
- 이번 문제도 역발상이 중요한 문제였다. 정방향으로 풀면 해결 할 수 없고, 역방향으로 해야지 해결할 수 있는 문제였다. 이와 유사한 아이디어가 필요한 문제가 [일곱난쟁이](https://www.acmicpc.net/problem/2309) 이다